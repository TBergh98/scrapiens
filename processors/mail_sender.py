"""Mail sender module for sending digest emails to researchers and alert summaries to admin.

This module sends emails generated by DigestBuilder to recipients, with optional test mode.
All credentials are loaded from .env file (not tracked in git).
"""

from __future__ import annotations

import json
import smtplib
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from jinja2 import Environment, FileSystemLoader, select_autoescape

from config import get_config
from config.settings import Config
from utils.file_utils import ensure_directory, load_json, save_json
from utils.logger import get_logger

logger = get_logger(__name__)


class MailSender:
    """Sends emails from digest JSON to recipients, with error tracking."""

    def __init__(
        self,
        config: Optional[Config] = None,
        template_dir: Optional[Path] = None,
        base_dir: Optional[Path] = None,
        dry_run: bool = False,
    ) -> None:
        """
        Initialize mail sender.

        Args:
            config: Configuration object (uses global if None)
            template_dir: Directory containing email templates
            base_dir: Base directory for file operations
            dry_run: If True, log emails instead of sending
        """
        self.config = config or get_config()
        self.base_dir = Path(base_dir) if base_dir else self.config.get_path('paths.base_dir')
        self.template_dir = Path(template_dir) if template_dir else (self.base_dir / "templates")
        self.dry_run = dry_run

        # Load SMTP config
        smtp_cfg = self.config.smtp_config
        self.smtp_server = smtp_cfg['server']
        self.smtp_port = smtp_cfg['port']
        self.login_user = smtp_cfg['login_user']
        self.login_pw = smtp_cfg['login_pw']
        self.use_tls = smtp_cfg.get('use_tls', True)
        self.mail_from = smtp_cfg.get('from_addr') or self.login_user
        self.reply_to = smtp_cfg.get('reply_to') or None
        self.alert_email = self.config.alert_email

        # Template environment
        self.env = Environment(
            loader=FileSystemLoader(self.template_dir),
            autoescape=select_autoescape(["html", "xml"]),
        )

        # Error tracking
        self.failed_sends: List[Dict[str, Any]] = []
        self.successful_sends: List[str] = []

    def find_latest_digest(self, directory: Optional[Path] = None) -> Path:
        """Return the most recent email_digests_*.json by timestamp in filename."""
        dir_path = Path(directory) if directory else self.config.get_full_path('paths.output_digests_dir')
        candidates = list(dir_path.glob("email_digests_*.json"))
        if not candidates:
            raise FileNotFoundError(f"No email_digests_*.json files found in {dir_path}")

        def _ts_from_name(path: Path) -> datetime:
            stem = path.stem
            parts = stem.split("_")
            ts = "".join(parts[-2:]) if len(parts) >= 2 else ""
            try:
                return datetime.strptime(ts, "%Y%m%d%H%M%S")
            except Exception:
                return datetime.fromtimestamp(path.stat().st_mtime)

        latest = max(candidates, key=_ts_from_name)
        return latest

    def send_digests(
        self,
        source_path: Path,
        mode: str = "full",
        test_recipients: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        """
        Send email digests to recipients.

        Args:
            source_path: Path to email_digests_*.json
            mode: "full" to send all, "test" to send samples to test_recipients
            test_recipients: Email list for test mode (prompted if None)

        Returns:
            Summary dict with sent count, failed, stats
        """
        source_path = Path(source_path)
        data = load_json(source_path)

        if not isinstance(data, dict) or "digests" not in data:
            raise ValueError("Input file must contain 'digests' list")

        digests = data["digests"]
        if not digests:
            logger.warning("No digests to send")
            return {
                "mode": mode,
                "total_digests": 0,
                "sent": 0,
                "failed": 0,
                "failed_recipients": [],
            }

        if mode == "test":
            # Select subset of recipients and prepare test data
            if test_recipients is None:
                test_recipients = self._prompt_test_recipients([d["email"] for d in digests])

            logger.info(f"Test mode: sending samples to {len(test_recipients)} recipients")

            # Build reduced digest for each test recipient (use first real digest)
            sample_digest = digests[0]
            test_digests = []
            for recipient in test_recipients:
                test_digest = {
                    **sample_digest,
                    "email": recipient,
                }
                test_digests.append(test_digest)
            digests = test_digests
        elif mode != "full":
            raise ValueError(f"Invalid mode: {mode}. Use 'full' or 'test'")

        # Send digests
        for digest in digests:
            self._send_single_digest(digest)

        # Compile summary
        summary = {
            "mode": mode,
            "total_digests": len(digests),
            "sent": len(self.successful_sends),
            "failed": len(self.failed_sends),
            "failed_recipients": [f["recipient"] for f in self.failed_sends],
            "timestamp": datetime.now().isoformat(),
        }

        logger.info(f"Digest sending: {summary['sent']} sent, {summary['failed']} failed")

        return summary

    def _send_single_digest(self, digest: Dict[str, Any]) -> None:
        """Send a single digest to its recipient."""
        recipient = digest["email"]
        html_body = digest.get("html_body", "")
        text_body = digest.get("text_body", "")

        try:
            subject = f"Digest bandi - {digest.get('total_grants', 0)} nuovi bandi trovati"
            self._send_email(
                to=recipient,
                subject=subject,
                html_body=html_body,
                text_body=text_body,
            )
            self.successful_sends.append(recipient)
            logger.info(f"✓ Sent digest to {recipient}")
        except Exception as e:
            error_msg = str(e)
            self.failed_sends.append({
                "recipient": recipient,
                "error": error_msg,
                "timestamp": datetime.now().isoformat(),
            })
            logger.error(f"✗ Failed to send digest to {recipient}: {error_msg}")

    def _send_email(
        self,
        to: str,
        subject: str,
        html_body: str,
        text_body: str,
    ) -> None:
        """Send a single email via SMTP."""
        msg = MIMEMultipart("alternative")
        msg["Subject"] = subject
        msg["From"] = self.mail_from
        msg["To"] = to
        if self.reply_to:
            msg["Reply-To"] = self.reply_to

        # Attach plain text and HTML
        msg.attach(MIMEText(text_body, "plain", "utf-8"))
        msg.attach(MIMEText(html_body, "html", "utf-8"))

        if self.dry_run:
            logger.info(f"[DRY RUN] Would send to {to}: {subject}")
            return

        # Send via SMTP (with optional TLS + auth)
        try:
            with smtplib.SMTP(self.smtp_server, self.smtp_port, timeout=30) as server:
                if self.use_tls:
                    server.starttls()
                if self.login_user:
                    try:
                        server.login(self.login_user, self.login_pw)
                    except Exception as login_err:
                        raise RuntimeError(f"SMTP login failed: {login_err}") from login_err
                server.sendmail(self.mail_from, to, msg.as_string())
        except Exception as e:
            raise RuntimeError(f"SMTP send failed for {to}: {str(e)}") from e

    def _prompt_test_recipients(self, available: List[str]) -> List[str]:
        """Prompt user for test recipient list."""
        print("\n" + "=" * 60)
        print("TEST MODE: Available recipients from digest:")
        for i, email in enumerate(available, 1):
            print(f"  {i}. {email}")

        print("\nEnter recipient numbers to receive samples (comma-separated):")
        print("Example: 1,3,5 (or just press Enter for first recipient)")

        user_input = input("> ").strip()
        if not user_input:
            return [available[0]] if available else []

        try:
            indices = [int(x.strip()) - 1 for x in user_input.split(",")]
            selected = [available[i] for i in indices if 0 <= i < len(available)]
            return selected if selected else [available[0]]
        except (ValueError, IndexError):
            logger.warning("Invalid input, using first recipient")
            return [available[0]] if available else []

    def send_alert_summary(
        self,
        digest_path: Path,
        extracted_path: Optional[Path] = None,
        match_path: Optional[Path] = None,
    ) -> Dict[str, Any]:
        """
        Build and send summary alert to admin email.

        Args:
            digest_path: Path to email_digests_*.json
            extracted_path: Path to extracted_grants_*.json (auto-found if None)
            match_path: Path to grants_by_keywords_emails_*.json (auto-found if None)

        Returns:
            Alert summary dict
        """
        # Load digest data
        digest_data = load_json(Path(digest_path))
        digests = digest_data.get("digests", [])

        # Auto-find extracted grants if not provided
        if extracted_path is None:
            try:
                extract_dir = self.config.get_full_path('paths.output_extract_dir')
                candidates = list(extract_dir.glob("extracted_grants_*.json"))
                if candidates:
                    extracted_path = max(candidates, key=lambda p: p.stat().st_mtime)
            except Exception:
                extracted_path = None

        extracted_data = load_json(extracted_path) if extracted_path else None
        total_extracted = 0
        extraction_success = 0
        if extracted_data and isinstance(extracted_data, dict):
            grants = extracted_data.get("grants", [])
            total_extracted = len(grants)
            extraction_success = sum(1 for g in grants if g.get("extraction_success"))

        # Auto-find keyword matches if not provided
        if match_path is None:
            try:
                match_dir = self.config.get_full_path('paths.output_match_keywords_dir')
                candidates = list(match_dir.glob("grants_by_keywords_emails_*.json"))
                if candidates:
                    match_path = max(candidates, key=lambda p: p.stat().st_mtime)
            except Exception:
                match_path = None

        match_data = load_json(match_path) if match_path else None
        grants_with_matches = 0
        total_emails = 0
        if match_data and isinstance(match_data, dict):
            grants_with_matches = match_data.get("grants_with_keyword_matches", 0)
            total_emails = match_data.get("total_emails", 0)

        # Compute success rates once for reuse below
        extraction_success_rate = (
            round(extraction_success / total_extracted * 100, 2) if total_extracted else 0
        )
        match_rate = round(grants_with_matches / total_extracted * 100, 2) if total_extracted else 0

        # Build warnings for alert
        warnings: List[str] = []
        if total_extracted == 0:
            warnings.append("Nessun bando estratto: controllare la pipeline di scraping/estrazione")
        if total_extracted > 0 and extraction_success_rate < 80:
            warnings.append(f"Tasso di successo estrazione basso: {extraction_success_rate}% (<80%)")
        if total_extracted > 0 and match_rate < 30:
            warnings.append(f"Tasso di match keyword basso: {match_rate}% (<30%)")
        if len(digests) == 0:
            warnings.append("Nessun destinatario nei digest generati")
        if len(self.failed_sends) > 0:
            warnings.append(f"Invii email falliti: {len(self.failed_sends)} (vedi dettagli sotto)")

        # Build context for template
        context = {
            "processing_date": datetime.now().isoformat(),
            "total_extracted_grants": total_extracted,
            "extraction_success": extraction_success,
            "extraction_success_rate": extraction_success_rate,
            "grants_with_keyword_matches": grants_with_matches,
            "match_rate": match_rate,
            "total_recipients": len(digests),
            "total_grants_in_digests": sum(d.get("total_grants", 0) for d in digests),
            "total_emails_in_system": total_emails,
            "failed_sends": self.failed_sends,
            "failed_sends_count": len(self.failed_sends),
            "successful_sends_count": len(self.successful_sends),
            "warnings": warnings,
            "warnings_count": len(warnings),
        }

        # Render alert email
        html_body = self._render_template("alert_summary.html", context)
        text_body = self._render_template("alert_summary.txt", context)

        # Send alert
        try:
            # Send alert to master email
            alert_email = "scouting.bandi@izsvenezie.it"  # ← CORRETTO
            self._send_email(
                to=alert_email,
                subject="[Scrapiens] Riepilogo elaborazione bandi e invio digest",
                html_body=html_body,
                text_body=text_body,
            )
            logger.info(f"✓ Alert sent to {alert_email}")
            context["alert_sent"] = True
        except Exception as e:
            logger.error(f"✗ Failed to send alert: {e}")
            context["alert_sent"] = False
            context["alert_error"] = str(e)

        return context

    def _render_template(self, template_name: str, context: Dict[str, Any]) -> str:
        """Render a template with context."""
        try:
            template = self.env.get_template(template_name)
            return template.render(**context)
        except Exception as e:
            logger.error(f"Template rendering failed for {template_name}: {e}")
            return f"Template error: {template_name}"


def send_emails(
    digest_path: Path,
    mode: str = "full",
    test_recipients: Optional[List[str]] = None,
    config: Optional[Config] = None,
) -> Dict[str, Any]:
    """Convenience wrapper to send digests in one call."""
    sender = MailSender(config=config)
    return sender.send_digests(digest_path, mode=mode, test_recipients=test_recipients)
